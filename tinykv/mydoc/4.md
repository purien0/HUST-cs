# project4
Project 4 通过建立一个事务系统实现多版本并发控制 MVCC。在编码之前，需要对事务的相关概念提前了解（事务的属性，事务隔离级别等）。
## 4a
project4A 实现一些基本操作，比如获取 value、给 lock、给 write 等等，供 project4B/C 调用，要完善的文件为 transaction.go。在进行具体实现之前，需要先了解三个前缀的结构。
注意区分：
| cf        | key                                     | value   |
| :---------- | :--------------------------------------- | :----- | 
| default      |         key+startTS                          | value |
| write | key+commitTS                        | write.toByte() |
| lock     | key           | lock.toByte() |

之后各方法按要求实现即可，以下选择一个方法讲解：
### CurrentWrite
查询当前事务下，传入 key 的最新 Write。

1.通过 iter.Seek(EncodeKey(key, math.MaxUint64)) 查询该 key 的最新 Write(排序按照key升序，时间戳降序)。
2.如果 write.StartTS > txn.StartTS，继续遍历，直到找到 write.StartTS == txn.StartTS 的 Write。
3.返回这个 Write 和 commitTs。

## 4b
完成server.go中KvGet, KvPrewrite, KvCommit的实现。
这里使用到latch实现，对一系列key进行上锁，
``` go
server.Latches.WaitForLatches(keys)
defer server.Latches.ReleaseLatches(keys)
```
### KvGet

1.从req中得到被读取的key
2.查看该key是否被上锁且锁的时间戳小于get请求，若是，返回该lockInfo。
3.调用GetValue方法找到最新值，若返回值为nil，resp上需将NotFound设置为true。
### KvPrewrite

2PC的第一阶段
1.得到被读取的keys
2.对每个key，找到最新的write记录，若存在write且提交时间戳大于该事务时间戳（写事务之间有覆盖情况，出现write conflict）
3.对每个key，找到最新的lock记录，若存在lock，则返回lockInfo
4.对每个key，上锁，执行操作（put/delete，rollback无需执行），并写入数据库。
### KvCommit

1.通过 Latches 上锁对应的 key；
2.对于每个key。检查lock。lock不存在可能是回滚导致，获取write，查看write类型并比较时间戳，若一致则设置Retryable并返回；lock存在但时间戳和该事务不符，可能是该lock已经过期被移除并被新事务加锁，设置Retryable并返回。
3.写入write，并删除lock

## 4c
### KvScan
从startKey开始扫描，扫描个数最大为limit。
``` go
type Scanner struct {
	// Your Data Here (4C).
	txn        *MvccTxn
	currentKey []byte
	iter       engine_util.DBIterator
}
```
currentKey初始设为startKey。

实现一个scanner，其scanner.next()会返回currentKey，value，err，并更新currentKey为下一个key值供下次调用时使用。当不存在下一个key值时currentKey设置为空。
KvScan顺序执行，注意当value为nil时，不将kvPair加入扫描结果resp.Pairs。
### KvCheckTxnStatus
检查事务状态，有locked，committed和rollback，根据primaryKey在该时间戳下的lock和write进行判断，以此决定是回滚还是继续推进 commit。
1.当前存在write且不为rollback：committed
2.存在write且为rollback，lock为nil：rollback
3.lock不为nil：检查ttl，超时则回滚（删除lock和该事务时间戳下的value，并写入write记录）
### KvBatchRollback
批量回滚，删除lock和该事务时间戳下的value。

可能遇到事务已提交、已回滚且有write记录、已回滚但无write记录的情况，依次予以设置Abort并返回、忽略、补充write记录。

### KvResolveLock
这个方法主要用于解决锁冲突，当客户端已经通过KvCheckTxnStatus()​检查了 primary key 的状态，要么全部回滚，要么全部提交，具体取决于 ResolveLockRequest​的CommitVersion​。

1. 通过 iter 获取到含有 Lock 的所有 key；
2. 如果 req.CommitVersion == 0，则调用 KvBatchRollback() 将这些 key 全部回滚；
3. 如果 req.CommitVersion > 0，则调用 KvCommit() 将这些 key 全部提交；

## debug
### keyNotFound error
err处理，storage.reader的GetCF方法在发生keyNotFound error会返回nil，nil。不能仅判断返回的err是否为nil来进行异常处理。
### 重复commit
```
=== RUN   TestCommitConflictRepeat4B
    commands4b_test.go:563: 
        	Error Trace:	/home/purein/桌面/tinykv/kv/transaction/commands4b_test.go:563
        	Error:      	Expected nil, but got: &kvrpcpb.KeyError{Locked:(*kvrpcpb.LockInfo)(nil), Retryable:"true", Abort:"", Conflict:(*kvrpcpb.WriteConflict)(nil), XXX_NoUnkeyedLiteral:struct {}{}, XXX_unrecognized:[]uint8(nil), XXX_sizecache:0}
        	Test:       	TestCommitConflictRepeat4B
--- FAIL: TestCommitConflictRepeat4B (0.00s)
```
这里模拟了重复commit操作，可以在KvCommit中检查到某个key没有被lock时查看是否已经存在一个startTs和commitTs都符合req的write，若这样直接忽略。

### TestRollbackOtherTxn4C
```
=== RUN   TestRollbackOtherTxn4C
    commands_test.go:148: 
        	Error Trace:	/home/purein/桌面/tinykv/kv/transaction/commands_test.go:148
        	            				/home/purein/桌面/tinykv/kv/transaction/commands_test.go:155
        	            				/home/purein/桌面/tinykv/kv/transaction/commands4c_test.go:130
        	Error:      	Not equal: 
        	            	expected: 1
        	            	actual  : 0
        	Test:       	TestRollbackOtherTxn4C
    commands_test.go:141: 
        	Error Trace:	/home/purein/桌面/tinykv/kv/transaction/commands_test.go:141
        	            				/home/purein/桌面/tinykv/kv/transaction/commands4c_test.go:131
        	Error:      	Not equal: 
        	            	expected: []byte{0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64}
        	            	actual  : []byte(nil)
        	            	
        	            	Diff:
        	            	--- Expected
        	            	+++ Actual
        	            	@@ -1,4 +1,2 @@
        	            	-([]uint8) (len=9) {
        	            	- 00000000  03 00 00 00 00 00 00 00  64                       |........d|
        	            	-}
        	            	+([]uint8) <nil>
        	            	 
        	Test:       	TestRollbackOtherTxn4C
--- FAIL: TestRollbackOtherTxn4C (0.00s)
```
可以看到我的write个数为0，预期结果为1。
分析：遇到锁的TS和当前Txn不同，可能是已经回滚完成，下一事务已经开始并上锁，这里需要写入一个rollback的write。
#### scan中忽略value为nil
```
=== RUN   TestScanEmpty4C
    commands4c_test.go:355: 
        	Error Trace:	/home/purein/桌面/tinykv/kv/transaction/commands4c_test.go:355
        	Error:      	
        	Test:       	TestScanEmpty4C
```
commands4c_test.go:355的位置为
``` go
assert.Empty(t, resp.Pairs)
```
要求resp.Pairs为空
分析：在scan操作中，value为nil时不要将得到的pair append到resp.Pairs。
#### scanner.next()的边界条件
```
=== RUN   TestScanAll4C
    commands4c_test.go:376: 
        	Error Trace:	/home/purein/桌面/tinykv/kv/transaction/commands4c_test.go:376
        	Error:      	Not equal: 
        	            	expected: 11
        	            	actual  : 10000
        	Test:       	TestScanAll4C
```
分析：边界条件处理，每次使用scanner.next()的同时也会找到下一个key来更新currenkey，但若两者相同，应将currentkey设置为nil。

#### scanner.next()遇到delete
```
=== RUN   TestScanDeleted4C
    commands4c_test.go:419: 
        	Error Trace:	/home/purein/桌面/tinykv/kv/transaction/commands4c_test.go:419
        	Error:      	Not equal: 
        	            	expected: 2
        	            	actual  : 1
        	Test:       	TestScanDeleted4C
--- FAIL: TestScanDeleted4C (0.01s)
```
找到报错代码：
``` go
assert.Equal(t, 2, len(resp2.Pairs)).
```
我的程序运行得到的是1，错误出现在存在delete行为时。

分析代码发现scanner.next方法遇到writekind为delete后还没有更新currentKey就直接返回了，导致一直搜索同一个被删除的kvpair。