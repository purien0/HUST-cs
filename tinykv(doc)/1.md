# project1
需要实现Standalone Storage。不同于之后实现的分布式存储引擎，这是一个单机的存储引擎，有助于初学者快速了解相关概念，也易于上手。
## Column Family
> Column Family，简称CF，就是将多个列合并为一个CF进行管理。这样读取一行数据时，你可以按照 CF 加载列，不需要加载所有列（通常同一个CF的列会保存在同一个文件中，所以这样有很高的效率）。此外因为同一列的数据格式相同，你可以针对某种格式采用高效的压缩算法。

对于我们要实现的KV数据库，key和value都是字符串类型，需要支持多列，如下所示：
|KEY|default|write|lock|
|---|---|---|---|
|key|v1|v2|v3|

当需要支持多列时，我们在key前面加一个前缀，如下所示：
|KEY|VALUE|
|---|---|
|default_key|v1|
|write_key|v2|
|lock_key|v3|

这样我们就可以用对key进行修饰来存储各列内容。

## Project1A
任务：完成StandAloneStorage的定义，实现NewStandAloneStorage、Reader和Write函数。

此处的主要任务在于理解概念。

根据项目文档，engine_util包 （kv/util/engine_util​）中提供了所有的读写操作，即需要封装的API。
查看其中doc文件内容，可以看到其中包含三个包，engines是存储引擎、write_batch是将多个写入整合到一个batch中，cf_iterator则是在badger中迭代列族。
对于engine类型，其中包含两个badger.DB类型的指针，两个string代表其路径。
``` go
type Engines struct {
	Kv     *badger.DB
	KvPath string
	Raft     *badger.DB
	RaftPath string
}
```
StandAloneStorage是Storage接口的具体实现，此外该接口还包含RaftStorage和MemStorage。
``` go
type Storage interface {
	Start() error
	Stop() error
	Write(ctx *kvrpcpb.Context, batch []Modify) error
	Reader(ctx *kvrpcpb.Context) (StorageReader, error)
}
```
此处选择将StandAloneStorage作为engines的封装，包含一个engine_util.Engines​成员。

NewStandAloneStorage根据config初始化StandAloneStorage。先从conf中取得dbPath，并生成kvpath和raftpath，调用两次CreateDB得到kvdb和raftdb，最后调用NewEngines生成引擎。

接下来实现接口函数，其中Start直接返回nil即可，Stop调用engine的Close方法。

Write函数进行engine实际的写操作，接受两个参数ctx *kvrpcpb.Context​和batch []storage.Modify，其中第一个参数无需使用。
查看参数定义，如下所示。
``` go
type Modify struct {
  Data interface{}
}

type Put struct {
  Key   []byte
  Value []byte
  Cf    string
}

type Delete struct {
  Key []byte
  Cf  string
}

func (m *Modify) Key() []byte {
  switch m.Data.(type) {
  case Put:
    return m.Data.(Put).Key
  case Delete:
    return m.Data.(Delete).Key
  }
  return nil
}

func (m *Modify) Value() []byte {
  if putData, ok := m.Data.(Put); ok {
    return putData.Value
  }

  return nil
}

func (m *Modify) Cf() string {
  switch m.Data.(type) {
  case Put:
    return m.Data.(Put).Cf
  case Delete:
    return m.Data.(Delete).Cf
  }
  return ""
}
```
Modify​中可以是类型为Put​或Delete​类型的Data​，使用.Key().Cf().Value()​取对应的字段。
实现时只需要遍历Modify切片，根据每个Modify执行put或delete操作即可。

Reader 方法，该方法返回一个 StoreageReader 接口，我们首先需要实现这个接口。
``` go
type StorageReader interface {
	// When the key doesn't exist, return nil for the value
	GetCF(cf string, key []byte) ([]byte, error)
	IterCF(cf string) engine_util.DBIterator
	Close()
}
```
根据文档提示，使用badger.txn来实现StoreageReader，定义一个StandAloneReader作为badger.txn的封装，并分别使用engine_util.GetCFFromTxn​、engine_util.NewCFIterator​、txn.Discard​实现GetCF()、IterCF()、Close()​。

回到StandAloneStorage的Reader函数，此处只需要调用en.Kv.NewTransaction​创建一个txn​，然后构造并返回一个StandAloneStorageReader​即可。
## Project1B
此处我们需要对StandAloneStorage进行一层封装，实现一个 K-V service handler，让读写操作以 API 的方式暴露出去供上层使用。这里要完善代码 kv/server/raw_api.go，其中包括 RawGet 、RawScan、RawPut、RawDelete。
四种方法接受对应的request，返回对应response和err。

对于get请求，使用Reader的GetCF方法；对于put和delete操作，将收到的请求转化为Modify切片并调用Write方法。只有RawScan稍显复杂，需要使用Reader​的迭代器iter遍历，首先Seek​到StartKey​的位置，然后取至多limit​个kvPairs​，用iter->Valid()检查是否有效，iter.Next()​进行遍历。

注：熟悉这四种操作的流程，在project4中也会涉及。

## debug
在StandAloneStorageReader，GetCF实现时，注意若出现badger.ErrKeyNotFound，需要返回nil，nil，上层会检测value是否为nil来判断是否出现badger.ErrKeyNotFound错误。
``` go 
if err == badger.ErrKeyNotFound {
		return nil, nil
	}
```